using OF.FSimMan.Game;
using OF.FSimMan.Management.Exceptions;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;

namespace OF.FSimMan.Management.Games
{
    public abstract class GameSettingsBase : AppSettingsBase
    {
        #region Properties
        internal Game _game;
        public abstract string ExeFileName { get; }
        public abstract string SettingsFileName { get; }
        public abstract string SteamId { get; }

        internal bool _isEnabled = false;
        public bool IsEnabled
        {
            get => _isEnabled;
            set => SetProperty(ref _isEnabled, value);
        }

        protected List<GameOrigin>? _gameOriginValues;
        public List<GameOrigin> GameOriginValues
        {
            get
            {
                if (_gameOriginValues == null)
                {
                    _gameOriginValues = Enum.GetValues<GameOrigin>().ToList();
                }
                return _gameOriginValues;
            }
            set => SetProperty(ref _gameOriginValues, value);
        }

        internal GameOrigin _gameOrigin = GameOrigin.DvdWebsite;
        public GameOrigin GameOrigin
        {
            get => _gameOrigin;
            set => SetProperty(ref _gameOrigin, value);
        }

        internal string _exeDirectoryPath = string.Empty;
        public string ExeDirectoryPath
        {
            get => _exeDirectoryPath;
            set => SetProperty(ref _exeDirectoryPath, value);
        }
        public bool IsExeDirectoryVisible
        {
            get
            {
                if (!_gameOrigin.Equals(GameOrigin.DvdWebsite)) return false;
                return true;
            }
        }

        public string ExeFilePath
        {
            get => Path.Combine(ExeDirectoryPath, ExeFileName);
        }

        internal string _dataDirectoryPath = string.Empty;
        public string DataDirectoryPath
        {
            get => _dataDirectoryPath;
            set => SetProperty(ref _dataDirectoryPath, value);
        }

        public virtual bool IsAutogenerationPossible
        {
            get
            {
                if (!IsEnabled) return false;
                if (IsExeDirectoryVisible && string.IsNullOrEmpty(ExeDirectoryPath)) return false;
                if (string.IsNullOrEmpty(DataDirectoryPath)) return false;

                InvokeModPackAutogenerationNowPossible();
                return true;
            }
        }

        internal bool _isAutogeneratedModPackExecuted = false;
        public bool IsAutogeneratedModPackExecuted
        {
            get => _isAutogeneratedModPackExecuted;
            set => SetProperty(ref _isAutogeneratedModPackExecuted, value);
        }

        public bool IsFullyConfigured
        {
            get
            {
                if (!IsAutogenerationPossible) return false;
                if (!IsAutogeneratedModPackExecuted) return false;

                return true;
            }
        }

        internal GameSettingsStartArguments _startArguments = new GameSettingsStartArguments();
        public GameSettingsStartArguments StartArguments
        {
            get => _startArguments;
        }
        #endregion

        #region Events
        public event EventHandler<AppSettingsModPackAutogenerationNowPossibleEventArgs>? ModPackAutogenerationNowPossible;
        #endregion

        #region Constructor
        public GameSettingsBase(Game game)
        {
            _game = game;
        }
        #endregion

        #region Methods PUBLIC
        public void TryAutodetectExePath()
        {
            string[] drives = Environment.GetLogicalDrives();

            ConcurrentBag<string> possibleFiles = new ConcurrentBag<string>();

            Parallel.ForEach(drives, drive =>
            {
                DriveInfo driveInfo = new(drive);
                if (!driveInfo.IsReady) return;
                if (driveInfo.DriveType != DriveType.Fixed) return;
#if DEBUG
                if (driveInfo.Name[0] == 'X') return;
#endif

                string[] directories = Directory.GetDirectories(drive, "*", SearchOption.TopDirectoryOnly);
                foreach (string directory in directories)
                {
                    try
                    {
                        List<string> hits = Directory.GetFiles(directory, ExeFileName, SearchOption.AllDirectories).ToList();
                        hits.ForEach(hit => possibleFiles.Add(hit));
                    }
                    catch (UnauthorizedAccessException) { }
                }
            });

            List<string> possibleFilesList = new List<string>(possibleFiles);

            possibleFilesList.RemoveAll(f => f.Contains("steam", StringComparison.OrdinalIgnoreCase));
            if (possibleFilesList.Count != 1) throw new GamePathAutodetectionFailedWarning();

            string? temp = Path.GetDirectoryName(possibleFilesList.Single());
            if (temp is null) throw new GamePathAutodetectionFailedWarning();

            try
            {
                ValidateExeDirectoryPath(temp);
            }
            catch { throw new GamePathAutodetectionFailedWarning(); }

            ExeDirectoryPath = temp;
        }

        public void TryAutodetectDataPath()
        {
            string temp = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            temp = Path.Combine(temp, "My Games", ExeFileName.Replace(".exe", string.Empty));

            if (!Directory.Exists(temp)) throw new DataPathAutodetectionFailedWarning();

            try
            {
                ValidateDataDirectoryPath(temp);
            }
            catch { throw new DataPathAutodetectionFailedWarning(); }

            DataDirectoryPath = temp;
        }

        public void ValidateExeDirectoryPath(string path)
        {
            string[] files = Directory.GetFiles(path);
            foreach (string file in files)
            {
                if (file.EndsWith(ExeFileName)) return;
            }
            throw new GamePathIncorrectException();
        }

        public void ValidateDataDirectoryPath(string path)
        {
            string[] files = Directory.GetFiles(path);
            foreach (string file in files)
            {
                if (file.EndsWith(SettingsFileName)) return;
            }
            throw new DataPathIncorrectException();
        }
        #endregion

        #region Methods PROTECTED
        protected override bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            bool hasChanged = base.SetProperty(ref field, value, propertyName);
            if (hasChanged)
            {
                OnPropertyChanged(nameof(IsExeDirectoryVisible));
                if (!IsExeDirectoryVisible && !string.IsNullOrWhiteSpace(ExeDirectoryPath)) ExeDirectoryPath = string.Empty;

                OnPropertyChanged(nameof(IsFullyConfigured));
            }
            return hasChanged;
        }
        #endregion

        #region Methods INTERNAL
        internal void UpdateHandlers()
        {
            StartArguments.StoreTrigger -= HandleStartArgumentsStoreTrigger;
            StartArguments.StoreTrigger += HandleStartArgumentsStoreTrigger;
        }
        #endregion

        #region Methods PRIVATE
        private void HandleStartArgumentsStoreTrigger(object? sender, AppSettingsStoreTriggerEventArgs e) => InvokeSettingsChanged(e);

        private void InvokeModPackAutogenerationNowPossible()
        {
            if (IsAutogeneratedModPackExecuted) return;

            ModPackAutogenerationNowPossible?.Invoke(this, new AppSettingsModPackAutogenerationNowPossibleEventArgs(_game));
        }
        #endregion
    }
}
